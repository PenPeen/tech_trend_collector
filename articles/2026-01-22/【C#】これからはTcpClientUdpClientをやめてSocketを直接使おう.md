# 【C#】これからはTcpClient/UdpClientをやめてSocketを直接使おう

## 記事情報

- **URL**: https://zenn.dev/nuskey/articles/csharp-dont-use-tcpclient
- **ソース**: Zenn
- **著者**: nuskey
- **公開日時**: 2026-01-21T09:24:18

## 要約

ご提示いただいた記事「C#でTcpClientを使ってはいけない（ことがある）」の要約です。

### 概要
この記事は、C#でネットワーク通信を実装する際、安易に`TcpClient`クラスを選択することの弊害と、より低レイヤーな`Socket`クラスを直接利用すべき理由について解説しています。特に高頻度な通信や高いパフォーマンスが求められる環境において、`TcpClient`が引き起こすメモリ管理の問題に焦点を当てています。

---

### 要点

#### 1. TcpClientの構造的な問題
*   `TcpClient`は内部で`Socket`クラスをラップしているだけの「薄いラッパー」ですが、通信のたびに`TcpClient`本体や`NetworkStream`などの**インスタンスが生成されるため、GC（ガベージコレクション）への負荷が大きくなります。**
*   特に高頻度で接続・切断を繰り返すような実装では、メモリ割り当てのオーバーヘッドが無視できなくなります。

#### 2. NetworkStreamのバッファリング不足
*   `TcpClient.GetStream()`で取得できる`NetworkStream`は、デフォルトでは内部バッファを持っていません。
*   そのため、小さなデータを頻繁に書き込むと、その都度システムコール（パケット送信）が発生し、パフォーマンスが著しく低下します。

#### 3. Socketクラスを直接使うメリット
*   `.NET Core 2.1`以降の`Socket`クラスには、`Memory<T>`や`ValueTask`に対応したメソッド（`ReceiveAsync` / `SendAsync`など）が追加されています。
*   これらを利用することで、**「ゼロアロケーション（メモリ割り当てなし）」での通信実装が可能**になり、GCによるアプリの停止（Stop-the-world）を最小限に抑えられます。

---

### 結論：使い分けの指針

*   **TcpClientを使っても良いケース：**
    *   数秒〜数分に1回
